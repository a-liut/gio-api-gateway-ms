/*
 * API Gateway Service
 *
 * API Gateway Microservice for the Gi√≤ system.
 *
 * API version: 1.0.0
 * Contact: andrea.liut@gmail.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package api

import (
	"encoding/json"
	"github.com/a-liut/gio-api-gateway-ms/src/model"
	"github.com/a-liut/gio-api-gateway-ms/src/repository"
	"net/http"

	"github.com/gorilla/mux"
)

func errorHandler(w http.ResponseWriter, status int32, message string) {
	r := model.ApiResponse{Code: status, Message: message}
	w.WriteHeader(int(status))
	json.NewEncoder(w).Encode(r)
}

func GetDeviceById(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["deviceId"]

	repo, _ := repository.NewDeviceRepository()
	device, err := repo.Get(id)

	if err != nil {
		errorHandler(w, http.StatusNotFound, err.Error())
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	json.NewEncoder(w).Encode(device)
}

func GetDevices(w http.ResponseWriter, r *http.Request) {
	repo, _ := repository.NewDeviceRepository()
	devices, err := repo.GetAll()

	if devices == nil {
		errorHandler(w, http.StatusNotFound, err.Error())
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	json.NewEncoder(w).Encode(devices)
}

func CreateDevice(w http.ResponseWriter, r *http.Request) {
	var d model.Device

	err := json.NewDecoder(r.Body).Decode(&d)
	if err != nil {
		errorHandler(w, http.StatusBadRequest, "Invalid data")
		return
	}

	repo, _ := repository.NewDeviceRepository()
	newDevice, err := repo.Insert(&d)

	if err != nil {
		errorHandler(w, http.StatusInternalServerError, err.Error())
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	json.NewEncoder(w).Encode(newDevice)
}
func GetDeviceReadings(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["deviceId"]

	repo, _ := repository.NewDeviceRepository()
	readings, err := repo.GetReadings(id)

	if err != nil {
		errorHandler(w, http.StatusInternalServerError, err.Error())
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	json.NewEncoder(w).Encode(readings)
}

// func GetInfrastructure(w http.ResponseWriter, r *http.Request) {
// 	vars := mux.Vars(r)
// 	id := vars["infrastructureId"]

// 	repo := repository.GetInfrastructureRepository()
// 	infr := repo.Get(id)

// 	if infr == nil {
// 		errorHandler(w, http.StatusNotFound, "Infrastructure not found")
// 		return
// 	}

// 	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
// 	w.WriteHeader(http.StatusOK)

// 	json.NewEncoder(w).Encode(infr)
// }

// func ListInfrastructures(w http.ResponseWriter, _ *http.Request) {
// 	repo := repository.GetInfrastructureRepository()
// 	infrs, err := repo.GetAll()

// 	if err != nil {
// 		errorHandler(w, http.StatusInternalServerError, "Cannot retrieve infrastructures")
// 		return
// 	}

// 	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
// 	w.WriteHeader(http.StatusOK)

// 	json.NewEncoder(w).Encode(infrs)
// }

// func InfrastructuresInfrastructureIdDelete(w http.ResponseWriter, r *http.Request) {
// 	vars := mux.Vars(r)
// 	id := vars["infrastructureId"]

// 	repo := repository.GetInfrastructureRepository()
// 	infr := repo.Get(id)

// 	if infr == nil {
// 		errorHandler(w, http.StatusNotFound, "Infrastructure not found")
// 		return
// 	}

// 	err := repo.Delete(infr)
// 	if err != nil {
// 		errorHandler(w, http.StatusInternalServerError, "Error during infrastructure deletion")
// 		return
// 	}

// 	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
// 	w.WriteHeader(http.StatusOK)
// }

// func InfrastructuresInfrastructureIdPost(w http.ResponseWriter, _ *http.Request) {
// 	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
// 	w.WriteHeader(http.StatusNotImplemented)
// }

// func RegisterInfrastructure(w http.ResponseWriter, r *http.Request) {
// 	var infr model.Infrastructure

// 	err := json.NewDecoder(r.Body).Decode(&infr)
// 	if err != nil {
// 		errorHandler(w, http.StatusBadRequest, "Invalid data")
// 		return
// 	}

// 	infr.ID = "temp"

// 	if ok, err := infr.Validate(); !ok {
// 		errorHandler(w, http.StatusBadRequest, err.Error())
// 		return
// 	}

// 	// Validate nodes
// 	nodeRepo, err := repository.NewNodeRepository()

// 	if err != nil {
// 		errorHandler(w, http.StatusInternalServerError, fmt.Sprintf("Cannot retrieve node data: %s", err))
// 		return
// 	}

// 	// Get all nodes first
// 	nodes := make(map[string]bool, len(infr.Nodes))
// 	for _, nodeID := range infr.Nodes {
// 		_, err := nodeRepo.Get(nodeID)

// 		if err != nil {
// 			errorHandler(w, http.StatusInternalServerError, fmt.Sprintf("Cannot retrieve node data: %s", err))
// 			return
// 		}

// 		// Set as valid the current node
// 		nodes[nodeID] = true
// 	}

// 	// Check node links
// 	for _, link := range infr.Links {
// 		if exists := nodes[link.Dst]; !exists {
// 			errorHandler(w, http.StatusInternalServerError, fmt.Sprintf("Linked node not found: %s", link.Dst))
// 			return
// 		}
// 	}

// 	repo := repository.GetInfrastructureRepository()
// 	err = repo.Insert(&infr)

// 	if err != nil {
// 		errorHandler(w, http.StatusInternalServerError, err.Error())
// 		return
// 	}

// 	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
// 	w.WriteHeader(http.StatusOK)

// 	json.NewEncoder(w).Encode(infr)
// }
